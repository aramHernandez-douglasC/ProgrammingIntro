**Week 3**
--

**Data structures, Functional and Object-Oriented Programming**

**Objective:** Understand the basic functionality of the main data structures (arrays, dictionaries,
stacks, queues, hash tables, linked lists, recursion, etc.) and have it applied in functional and object-oriented
programming

**Day 1:**
- Data structures:
  - What is an array and it's main usage
  - Algorithms using data structures
  - What is and how recursion works
  - Sorting algorithms and DS

**Day 2:**

**OOP and FOP**

Object-Oriented Programming (OOP) is a programming paradigm based on the concept of “objects”, which are 
containers for data (attributes) and behavior (methods). It models real-world entities and their interactions 
in a modular and reusable way.

**Goals of OOP**
- Encapsulation: Keep data safe and hidden inside objects.
- Modularity: Divide the program into independent parts (objects).
- Reusability: Reuse code through inheritance and composition.
- Scalability: Build complex systems with well-structured, maintainable code.

**Core Concepts of OOP**

Class
- A blueprint for creating objects.
- Defines the attributes and methods that objects of that class will have.

Object
- An instance of a class
- Has its own state (data) and behaviors (methods).

**OOP Principles**

- **Encapsulation** – “Hide the internal state”
Bundling data (attributes) and methods (functions) that operate on that data into a single unit — the object.
Internal details are hidden to protect the integrity of the object.
Why?
Prevents external code from modifying the internal state in unintended ways.
Makes the object easier to use and understand.
- **Abstraction** – “Expose only what's necessary”
Hiding complex implementation details and exposing only the relevant parts to the user.
Why?
Simplifies usage.
Reduces complexity.
Encourages focus on what an object does, not how it does it.
- **Inheritance** – “Reuse and extend behavior”
One class (child/subclass) can inherit the attributes and behaviors of another (parent/superclass).
Why?
Promotes code reuse.
Enables hierarchical relationships (e.g., Animal → Dog).
Reduces duplication.
- **Polymorphism** – “Same interface, different behavior”
Objects of different classes can be treated through a common interface, but each can behave differently.
Why?
Promotes flexibility and scalability.
Enables generic code that can work with any subclass.


**Composition**
Even though this isn't an oop principle, it is still and important concept and it means

- "Has-a" relationship: instead of inheriting, one object contains another.
- Promotes flexibility and loose coupling.


**SOLID Principles (OOP Design Guidelines)**
-

S – Single Responsibility Principle

- A class should have only one reason to change.
- Keep classes focused and cohesive.

O – Open/Closed Principle

- Classes should be open for extension, closed for modification.
- Use inheritance, interfaces, or composition to extend behavior.

L – Liskov Substitution Principle

- Subclasses should be usable in place of parent classes without breaking the code.

I – Interface Segregation Principle

- Many small, specific interfaces are better than one big general-purpose interface.

D – Dependency Inversion Principle

- Depend on abstractions, not concrete implementations.
- Invert control to make code more flexible.









